<!DOCTYPE html>
<html>
<head>
    <title>Lesson 8</title>
    <link rel ="stylesheet" href = "Styles/loadingpage.css">
    <link rel = "icon" type = "image/x-icon" href = "Imgs_and_stuff/pngwing.com (1).png">
    <link rel = "stylesheet" href = "Styles/mainpage.css">
    <link rel = "stylesheet" href = "Styles/LessonScreenFormat.css">
    <link rel = "stylesheet" href = "Styles/AlternateContentDisplay.css">
</head>

<body>
    <section class = "showcase" id = "main">
            <header class = "pageheader">
                <h2 class="main_logo" id = "main-logo"><a href = "index.html">&lt;Web@RC&gt;</a></h2>
                <span class = "main_toggle" onclick="openNav()"></span>
            </header>
            
                <div class = "main_text" id = "main-text">
                    <h2>
                        Lesson 8:
                        <br>
                        Game Development: Introduction to Phaser
                    </h2>
                    <dialog class = "Lecture" id="LectureVid">
                        <div class = "LectureVideo">
                            <div>
                                <h2 style = "margin-bottom: 10px; margin-top: 50px;">Lesson 8 Video Recording:</h2>                               
                                <button id = "closeButtonModal" style = "margin-bottom: 10px; margin-top: 50px;"></button>
                            </div>
                            <video id = "modalVideo"controls = "true" autoplay = "false" style = "position:static; opacity: 1; object-fit: contain; height: 100%; width: 100%; display: block;">
                                <source src = "Imgs_and_stuff/blurred_video_of_scripts_being_typed (1080p).mp4" type = "video/mp4">
                            </video>
        
                        </div>
                    </dialog>
                    <a data-open-modal class = "LectureButton" id = "openModal">Watch Recording</a>
                    <video class = "main_video" src= "Imgs_and_stuff/blurred_video_of_scripts_being_typed (1080p).mp4" autoplay loop muted playsinline preload = "none"></video>
              </div>
       

        <div class = "lessonformat">
            <div class = "container">
                <div class = "tabs">
                    <h3 class = "letab active">Setting up phaser</h3>
                    <h3 class = "letab">Classes and Sub-classes</h3>
                    <h3 class = "letab">Groups and Children</h3>
                    <h3 class = "letab">Making sprites and creating the player</h3>
                    <h3 class = "letab">Keys and updates</h3>
                    <h3 class = "letab">Making the enemies</h3>
                    <h3 class = "letab">Walls and collisions</h3>
                    <h3 class = "letab">Running the game</h3>


                </div>

                <div class = "tab-content">
                    <div class = "active fade">
                            <h2 class = "HeaderPoint">Preresiquite downloads</h2><h3>Before making the game, you will need these installed:</h3>
                            <div class = "inactive">

                                <h2 class = "contentTitle">Downloading Nodejs</h2>
                                <a href = "https://nodejs.org/en/download" target="_blank">
                                    Click me to go to the website to download NodeJS.
                                </a>

                                <h2 class = "contentTitle">Downloading phaser</h2>
                                <h3>To download phaser, type this command into your terminal which you want Phaser to be on:
                                    <br><code>
                                        npm install phaser
                                    </code>
                                </h3>
    
                                <h2 class = "contentTitle">Copy and paste this command in your repositories terminal in Visual Studio Code</h2>
                                <h3>
                                    <code>gh repo clone ourcade/phaser3-vite-template</code>
                                </h3>
    
                            </div>
                        </div>

                        <div class = "fade">
                        <h2 class = "HeaderPoint">What are classes?</h2>
                        <h3>
                            Classes in Javascript are an easy way to define and create objects with a blueprint for their properties and methods. Much like Json, they can be used to easily store information about an object.
                        </h3>

                        <h2 class = "contentTitle">Method</h2>
                        <h3>
                            Methods in Javascript are functions that are associated with a class or an object, which represents behavior or actions that objects of the class can perform. When a method is called, it can access and manipulate the data within the object it belongs to, and it can also interact with other objects or perform other operations.
                        </h3>

                        <h2 class = "contentTitle">Constructor</h2>
                        <h3>
                            A constructor is a special method that is called when an instance of a class is created. It is used to initialize the newly created object and to set initial values for its properties and perform any other setup that may be required.
                             Think of it like attributes that a class has, that is loaded before any of the methods take place.
                        </h3>

                        <h2 class = "contentTitle">Making classes</h2>
                        <h3>
                            To make a class, you use the syntax:
                            <code>class example {
                                <br>&emsp;constructor(property1, property2) {
                                <br>&emsp;&emsp;this.property1 = some property 1;
                                <br>&emsp;&emsp;this.property2 = some property 2;
                                <br>&emsp;}

                                <br><br>&emsp;method1 {
                                    <br>&emsp;&emsp;method logic here
                                <br>&emsp;}

                                <br><br>&emsp;method2 {
                                    <br>&emsp;&emsp;method logic here
                                <br>&emsp;}
                                <br>}
                            </code>
                            <br><br>Keep in mind that you can have as many properties and methods as you want. To assign something to a class, use the syntax: 
                            <br><code>let name_of_object = new example(property1, property2)</code><br> but replace name of object with the name of what you want to call it, example to your class name, and the properties.
                            <br><br> To call a method, use the syntax:
                            <br><code>name_of_object.method1()</code><br> and replace the placeholders accordingly.

                        </h3>
                        
                        <h2 class = "contentTitle">Example of classes</h2>
                        <h3>Say, you want to have a class 'Circle' that you can call, and you want to be able to get its area. You can make a class like this:<code>
                            <br>class Circle {
                                <br>&emsp;constructor(radius) {
                                    <br>&emsp;&emsp;this.radius = radius;
                                <br>&emsp;}
                              
                                <br><br>&emsp;getArea() {
                                    <br>&emsp;&emsp;return Math.PI * this.radius * this.radius;
                                <br>&emsp;}
                              
                                <br><br>&emsp;setRadius(newRadius) {
                                    <br>&emsp;&emsp;this.radius = newRadius;
                                <br>&emsp;}
                              <br>}</code>
                              <br> In this example, you can see that the properties are radius, and the methods are getArea() and setRadius(newRadius).
                        </h3>
                        <h3><br>
                            Or, you want to have a counter that you can add or delete values from: <code>
                                <br>class Counter {
                                    <br>&emsp;constructor() {
                                        <br>&emsp;&emsp;this.count = 0;
                                    <br>&emsp;}
                                  
                                    <br><br>&emsp;increment() {
                                        <br>&emsp;&emsp;this.count++;
                                    <br>&emsp;}
                                  
                                    <br><br>&emsp;decrement() {
                                        <br>&emsp;&emsp;this.count--;
                                    <br>&emsp;}
                                  <br>}
                            </code>
                            <br><br>As you can see, calling the increment() function in the class Counter would raise it by 1, while calling decrement() would decrease the counter by 1. So, if you decide to run <code>Counter.increment()</code>, <code>this.count</code> would increase by 1.

                        </h3>

                        <h2 class = "contentTitle">Subclasses</h2>
                        <h3>
                            Sub-classes, also known as derived classes or child classes, are classes that inherit properties and methods from another class, known as the superclass, base class, or parent class. When a class inherits from another class, it automatically gains access to all the public and protected members (properties and methods) of the parent class.
                            The sub-class can also add its own methods and properties, as well as override or extend the behavior of the inherited methods.

                            For example, consider this class:<code>
                            class Animal {
                                <br>&emsp;constructor(name) {
                                    <br>&emsp;&emsp;this.name = name;
                                <br>&emsp;}
                                
                                <br>&emsp;speak() {
                                    <br>&emsp;&emsp;console.log(this.name + ' makes a noise.');
                                <br>&emsp;}
                              <br>}</code>

                              <br>As seen from the example, the class animal makes a noise whenever it speaks. However, what if we specifically want a dog (which belongs under the class animal) to bark instead? 
                              To do that, we can assign a sub-class:
                              <code>
                                <br>class Dog extends Animal {
                                    <br>&emsp;speak() {
                                        <br>&emsp;&emsp;console.log(this.name + ' barks.');
                                    <br>&emsp;}
                                  <br>}
                              </code>
                              
                              <br>As seen from above, you can use <code>extend</code> to make a subclass (in this case dog of animal), which has all the properties of the class <code>animal</code> but also special methods.<br/><br/>
                              The syntax to make a subclass is:
                              <code>
                                <br> class subclass_name extends parent_class_name {
                                    <br>&emsp;method {
                                        <br>&emsp;&emsp; method logic here
                                    <br>&emsp;}
                                <br>}
                              </code>

                        </h3>

                        <h2 class = "contentTitle">Superclass</h2>
                        <h3>
                            As the name suggests, superclass is the opposite of subclass; used specifically in subclass to refer to its parent class, usually in the method or constructor of a subclass. It is particularly useful in cases where you are extending a class using the "extends" keyword and need to access and initialize the parent class's properties. <br/><br/>
                            To reference a superclass, the syntax is:
                            <br><code>
                                method {
                                    <br>&emsp; method logic
                                <br>&emsp; super()
                                    <br>&emsp; method logic
                                <br>}
                            </code>
                        </h3>
                    </div>

                    <div class = "fade">
                        <h2 class = "HeaderPoint">Groups and Children</h2>
                        <h2 class = "contentTitle">Groups</h2>
                        <h3>
                            A group, more commonly known as a parent, is similar to a class, where it can be used to store information about an object. What differs it from a class, is that it cannot have sub-classes, where instead it has <b>children</b>, which are elements within the parent. These children can be referenced individually or as a collective whole (which will be shown below) and each of them will have the properties of the parent. Essentially, you can think of the child being a subclass of the parent.
                        </h3>

                        <h2 class = "contentTitle">ForEach()</h2>
                        <h3>In JavaScript, the "forEach" method is used to iterate over elements in an array or element. It allows you to execute a function for each element, providing a clean and concise way to perform operations on array elements without needing to use a loop. For example: you have the list:<br>
                             <code>array = [1, 2, 3, 4, 5]
                                <br>array.ForEach(function(element) {
                                    <br>&emsp;console.log(element)
                                <br>});
                             </code>
                             <br>If you type this into your JavaScript file, you should see in the console, that 1, 2, 3, 4, 5 are displayed in order. The ForEach function, in short, executes a function for every child there is in the parent class. We will be using this to assign properties to enemies later. The general syntax for this function would be:
                             <code>
                                <br>array.ForEach(function(element) { // the function here indicates that for each element it is supposed to execute a function, which is indside the curly brackets.
                                    <br>&emsp;logic here
                                <br>});
                             </code>
                             <br>Where you can change array and element to whatever names and parameters you want.
                            </h3>

                            <h2 class = "contentTitle">[i]</h2>
                            <h3>Instead of referencing every child, this function <b>only</b> executes code for the specific child i, where i is the n+1th child in the parent. So, using the example of the array above, if you type:
                            <code>
                                <br>console.log(array[2])
                            </code>
                            <br>What should appear in the console is the number 3, since that is the third element in the array, starting from 0.
                            </h3>

                            <h2 class = "contentTitle">querySelectorAll()</h2>
                            <h3>The querySelectorAll() method returns all children that has the elements listed in the parameters. 
                                You can then manipulate or access the elements in the list using standard JavaScript methods to iterate through the collection, such as forEach() or by index like an array. Keep in mind that the list returned by querySelectorAll() is not live, 
                                meaning it doesn't automatically update if the document changes. If elements that match the selectors are added or removed from the document after the list is created, it will not be automatically updated.</h3>
                    </div>

                    <div class = "fade">
                        <h2 class = "HeaderPoint">Making sprites</h2>
                        <h3>
                            To make sprites, I recommend you use a software that makes a sprite sheet for you, given that you draw the animations. This reduces the amount of load on the local host when loading an animation, which can improve its optimisation.
                            However, if you are not familiar with spritesheets or do not have a software that can do such thing, putting pngs of animations are also fine. If you don't have a sprite making software, there is this <a href = "https://www.piskelapp.com/p/create/sprite">Online application</a> that can make pixel art, although you can make other sprites.
                        </h3>
                        <h2 class = "contentTitle">create()</h2>
                        <h3>
                        Create(), not to be confused with object.create(), a default command in Javascript, in phaser is defined as a special built-in constructor to generate game content, without the need of external files. Within the <code>create()</code> method, you can include code to create sprites, set up physics, add text or buttons, and perform various other initializations necessary for setting up the game environment. For example:
                        <br><code>create() {
                            <br>&emsp;var screen = this.add.image(100, 100, 'screen'); //we will talk about adding sprites later on
                            <br>&emsp;this.add.text(50, 50, 'Welcome to the game', { font: '24px Arial', fill: '#ffffff' });
                            <br>&emsp;Other methods or functions...
                        <br>}</code>
                        <br>Note that the syntax for adding sprites is <code>this.add.sprite(x coordinate, y coordinate, sprite1, sprite2, ...)</code>, where x and y coordinates are measured from the top left of the screen (0,0) in pixels.
                        <br><br/>Thus, the general syntax for create would be:<code>
                        <br>create() {
                            <br>&emsp;var object = this.add.sprite(x-coordinate,y-coordinate, sprite1, sprite2, ...)
                            <br>&emsp;Methods or functions of sprite
                        <br>}</code>
                        <br>Be sure to switch object, coordinates, and sprites accordingly.
                        </h3>

                        <h2 class = "contentTitle">createPlayer()</h2>
                        <h3> This is the method that I call for creating the player. you can rename it to however you like, but the purpose should remain the same: to create the player.
                            To make the player, first you have to define the sprite using <code>const player = this.physics.add.sprite(x-coordinate, y-coordinate, sprite name)</code>. The x and y coodinates are where the player would spawn, and adding physics makes the object be able to move.
                            <br>Then, you would need to do player.setCollideWorldBounds(true), to ensure that the player doesn't fall out of the screen (ofcourse, you can ignore this if it is intended in your game).
                            <br>After that, you would need to input your animations, using the syntax: <br><code><br>this.anims.create({<br>&emsp;key: ,<br>&emsp;frames: ,<br>&emsp;frameRate: ,<br>&emsp;repeat: <br>})<br></code><br> where the key is whatever you want to name the animation (to call it later), frames being the individual frames using: <br><br><code>this.anims.generateFrameNumbers(sprite name, { start: starting frame, end: ending frame })</code><br><br> frameRate is the number of frames played per second (default being 60, but i advise around 10-12 if you have short anims of around 5 frames each), and repeats are the number of times you want the animation played. You can create as many animations as you wish, just make sure that they have a different key.
                            Overall, your method for creating the player should look something like this:
                            <br><br>createPlayer() {
                                <br>&emsp;const player = this.physics.add.sprite(x-coordinate, y-coordinate, sprite )
                                <br>&emsp;player.setCollideWorldBounds(true) 

                                <br><br>&emsp;this.anims.create({
                                    <br>&emsp;&emsp;key: 
                                    <br>&emsp;&emsp;frames:
                                    <br>&emsp;&emsp;frameRate:
                                    <br>&emsp;&emsp;repeat: // -1 for infinite looping

                                <br>&emsp;})
                            <br>}
                        </h3>

                        <h2 class = "contentTitle">preload()</h2>
                        <h3>
                            The preload() function is a method you put inside of a class where it preloads everything in the class as you call it (similar to an instructor). However, as implied, they are already loaded before you call the class, meaning they are global variables. For the purpose of these lessons, we encourge you to put the following objects in preload: Background images, Player & Enemy spritesheets, as well as CursorKeys and keyboard keys (Which will be discussed in the next lesson). 
                            Putting everything in, this should be what your preload() looks like right now:
                            <code>preload(){ 
                                <br>&emsp;this.load.image('Background', 'assets/game_banner.png')
                                <br>&emsp;this.load.spritesheet('guy', 'assets/Stickman.png', {frameWidth: 28, frameHeight: 34})
                                <br>&emsp;this.load.image('enemy', 'assets/enemy.png')                        
                            <br>}</code>
                            
                        </h3>
                    </div>

                    <div class = "fade">
                        <h2 class = "HeaderPoint">update(), CursorKeys, Keyboard keys</h2>
                        <div class = "inactive">
                            <h2 class = "contentTitle">update()</h2>
                            <h3> The update() command is a command you put in your class which tells the game what to look out for when it updates in-game (depending on your framerate, it may go from 10-60 per second). Some examples which we will be using in the next lesson are: Movement keys (W,A,S,D), Left & Right mouse button click, Healthbar, and Stamina. Ofcourse, this selection is chosen because it will be relevant to our exercise, but note that anything that needs updating will be put here. Heres an example:
                                <code><br>var keys = this.input.keyboard.addKeys("W,A,S,D")</code> // adds W, A, S, D keyboard keys to be detected by the game, if you want to use arrow keys, use the syntax: this.cursor = this.input.keyboard.createCursorKeys() and <b>put it in create() instead of update()</b>. Then, simply replace 'keys.A.isDown' with 'this.cursors.left.isDown' and do it for the other movement directions. You can change the parameters inside to change the speed.
                                    <code><br>if (keys.A.isDown)
                                    <br>{
                                        <br>&emsp;this.player.setVelocityX(-160)
                            
                                    <br>}
                                    <br>else if (keys.D.isDown)
                                    <br>{
                                        <br>&emsp;this.player.setVelocityX(160)
                            
                                    <br>}
                                    <br>else this.player.setVelocityX(0)
                                
                                    <br><br>if (keys.W.isDown)
                                    <br>{
                                        <br>&emsp;this.player.setVelocityY(-160)
                            
                                    <br>}
                                    <br>else if (keys.S.isDown)
                                    <br>{
                                        <br>&emsp;this.player.setVelocityY(160)
                            
                                    <br>}
                                    <br>else this.player.setVelocityY(0)</code>
                            </h3>
                            <h2 class = "contentTitle">Cursor and Keyboard keys<h2>
                                <h3>
                                    As seen from above, Phaser itself does not recognise cursor and keyboard keys by default, so you'll have to import them. To import cursor keys (arrow keys and space bar) you use the syntax: <br> <code>this.cursors = createCursorKeys()</code><br> in preload() or create(), while if you want to import specific keys on your keyboard, use the syntax: <br> <code>var keys = this.input.keyboard.addKeys('add your key here', 'key 2', ...) </code><br>in update() or create().
                                </h3>
                        </div>
                        
                    </div>

                    <div class = "fade">
                        <h2 class = "HeaderPoint">Making enemies</h2>
                        <div class = "inactive">
                            <h2 style = "margin-bottom: 20px; margin-left: 10px; margin-top: 20px; border-bottom-style: solid; border-bottom-color: rgba(0, 0, 0, 0.2)">
                            Time to make the enemies!</h2>
                            <h3>
                                By this point, you should have some enemy sprites ready to use as your enemies. In this tutorial, We are going to make enemies that travel towards the player in a straight line.

                            </h3>
                            <h2 class = "contentTitle">Enemy class</h2>
                            <h3>
                               Unfortunately, making enemies are not as simple as making the player. To make the enemies, I recommend opening a new file, and naming it <code>enemies.js</code>. Inside it, you should import phaser again, then use <code>export default class enemy_name {}</code> to make a class of enemies.
                            </h3>

                            <h2 class = "contentTitle">Enemy constructor</h2>
                            <h3>After making the class of enemies, you would want to add a constructor. Inside the constructor, you want it to recognise both the scene and the key, so you you can use the syntax:
                                <code>constructor(scene, enemy = 'enemy') {
                                    <br>&emsp;this.scene = scene
                                    <br>&emsp;this.key = enemy
                                    <br>&emsp;this._group = this.scene.physics.add.group()
                                <br>}</code><br>
                                to set your enemy constructor. the <code>_group</code> tag is to assign a group to every active enemy, so we don't have to set new code for each enemy that appears. Do note that it is good practice to set a function to call the group, with the syntax as follows (make sure it is out of the constructor):
                                <code><br>get group()
                                    <br>&emsp;{
                                        <br>&emsp;&emsp;return this._group
                                        <br>&emsp;}</code>
                            </h3>

                            <h2 class = "contentTitle">Spawning the enemy</h2>
                            <h3>To spawn the enemy, we are going to create a method in the class of enemies called<code>spawn()</code>. In the spawn, you want to clarify where the enemy spawns. Therefore, you should have the following syntax:</h3>
                            <h3><code>spawn()
                                <br>{
                                    <br>&emsp;const xrand = Math.floor(Math.random() * 1701) // randomises the X axis at which the enemy spawns
                                    <br>&emsp;const yrand = Math.floor(Math.random() * 1001) // randomises the Y axis at which the enemy spawns
                            
                            
                                    <br>&emsp;const enemyguy = this.group.create(xrand, yrand, this.key) //creates an enemy which belongs to the group and has random coordinates
                                    <br>&emsp;enemyguy.setVelocity(Phaser.Math.Between(-0, 0), 0) // setvelocity things to make sure it doesnt move
                            
                                    
                            
                                    <br>&emsp;return enemyguy
                                <br>}</code><br>Then, to spawn the enemy, you simply use the syntax in create() in your main scene: 
                            <code>
                                this.name_your_spawn_function = new enemies(this, 'enemy') //you are free to change enemies to the name of your other js file, and 'enemy' to whatever you want to tag your enemies as.
                            </code></h3>


                            <h2 class = "contentTitle">Spawning mutliple enemies</h2>
                            <h3>Often if your games, you wouldn't just want 1 enemy, right? now, ofcourse we can just run the spawn function more, but that would be tedious. Therefore, we are going to use a loop to spawn the enemies. Using the syntax:
                                <code>
                                    <br>function Count(i) { //change the name of the function to however you want
                                        <br>&emsp;if (i &lt;= 4) { //change the value to how many enemies you want to spawn
                                            <br>&emsp;&emsp;that.enemyspawn.spawn() // change enemyspawn and spawn to your defined functinos
                                            <br>&emsp;&emsp;setTimeout(() => Count(i+1), 1000); //  change the value to how many miliseconds per enemy.
                                            <br>&emsp;}
                                            <br>}
                                    <br>Count(1); //Since computers start counting at 0, putting the parameter as 2 will spawn exactly the number of enemies listed beside i. OR, you can use &lt; instead and start at 0.
                                </code> </h3>
                                <h3>We are going to discuss Enemy AI and pathfinding next lesson, so right now you should just have static enemies that spawn.</h3>
                        </div>
                    </div>

                        <div class = "fade">
                            <h2 class = "HeaderPoint">Making walls</h2>
                            <div class = "inactive">
                            <h3>Ofcourse,  you wouldn't want the player to be able to travel everywhere, or have the game be too easy. Keep in mind that we are going to be adding collisions altogether next lesson (enemy collisions and wall collisions), so these walls don't really work for now... By this point, you should have an image of some wall.</h3>
                            <h2 class = "HeaderPoint">Creating the walls</h2>
                            <h3>Similar to the player, we are going to create a new method to make walls. Naming the method whatever you want, you basically just create an image of your wall wherever you want it to be. Thankfully, the syntax isn't that complicated:
                                <code>
                                    createWall() // or whatever you want to name your method
                                    <br>{
                                        <br>&emsp;const wall = this.physics.add.staticGroup() // don't worry if you don't know what this is, we will discuss it next lesson.
                                
                                        <br>&emsp;wall.create(1050, 300, 'wall').setScale(1.5).refreshBody() // creating the wall and scaling it up, rename 'wall' to whatever the image of your wall is called, add more if needed
                                
                                        <br>&emsp;return wall
                                    <br>}<br>
                                </code>
                                With this code, to spawn a wall, you just use the syntax <code>this.createWall() in create()</code>, which should spawn your wall(s). It is also noted that you can add parameters into the method of its coordinates instead of them being fixed, if you fancy typing them in brackets outside instead.
                                So, your wall code would look like this:<br>
                                <code>
                                    createWall(x, y) // or whatever you want to name your method
                                    <br>{
                                        <br>&emsp;const wall = this.physics.add.staticGroup() // don't worry if you don't know what this is, we will discuss it next lesson.
                                
                                        <br>&emsp;wall.create(x, y, 'wall').setScale(1.5).refreshBody() // creating the wall and scaling it up, rename 'wall' to whatever the image of your wall is called, add more if needed
                                
                                        <br>&emsp;return wall
                                    <br>}
                                </code>
                            </h3>

                            </div>
                        </div>

                        <div class = "fade">
                            <h2 class = "HeaderPoint">Running the game</h2>
                            <div class = "inactive">
                                <h2 class = "contentTitle">Starting the game</h2>
                                <h3>See if your code works! To run the game, go to your terminal and type:<br>
                                    <code>
                                        npm run start
                                    </code>
                                    <br>This should produce a localhost link and an online link. For now, click the localhost link and it should bring you to your game. Upon loading, you should see your player, and it being able to move with WASD or otherwise, some static enemies spawning, and some walls.
                                     If you do, thats great! Next lesson, we will be discussing how to make your game feel alive and fun. 
                                </h3>
                            </div>
                        </div>
                    </div>
                </div>
            </div>  
        </div>

        <div class = "footer" id = "main-text">
            <a class = "LectureButton bottombuttons" href="lesson-7-page.html">Previous Lesson</a>
            <a class = "LectureButton bottombuttons" href="lesson-9-page.html">Next Lesson</a>
        </div>
    </section>

    <div id = "main_side" class="main_menu"></div>
</body>

    <div class = "loader"></div>
    <div class = "loading" src = "Imgs_and_stuff/rat.jpg"></div>

    <script src = "Javascript/sidemenu.js"></script>
    <script src = "Javascript/loader.js"></script>
    <script src= "Javascript/AlternativeContentDisplay.js"></script>
    <script src = "Javascript/videoModal.js"></script>
</html>